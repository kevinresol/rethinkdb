package ;
import rethinkdb.RethinkDB.r;
import rethinkdb.reql.*;
using tink.CoreApi;

@:await class TestControl extends TestBase {
	@:async
	override function test() {
		var _tables = ["tbl", "tbl2"];
		@:await createTables(_tables);
		var tbl = r.db("test").table("tbl"), tbl2 = r.db("test").table("tbl2");
		@:await assertAtom(2, r.expr(1).do_(function(v:Expr):Expr return v * 2));
		@:await assertAtom(([0, 1, 2, 3] : Array<Dynamic>), r.expr(([0, 1, 2] : Array<Dynamic>)).do_(function(v:Expr):Expr return v.append(3)));
		@:await assertAtom(3, r.do_(1, 2, function(x:Expr, y:Expr):Expr return x + y));
		@:await assertAtom(1, r.do_(function():Expr return 1));
		@:await assertError(err("ReqlQueryLogicError", "Expected function with 2 arguments but found function with 1 argument.", ([1] : Array<Dynamic>)), r.do_(1, 2, function(x:Expr):Expr return x));
		@:await assertError(err("ReqlQueryLogicError", "Expected function with 3 arguments but found function with 2 arguments.", ([1] : Array<Dynamic>)), r.do_(1, 2, 3, function(x:Expr, y:Expr):Expr return x + y));
		@:await assertAtom(1, r.do_(1));
		@:await assertError(err("ReqlQueryLogicError", "Expected type ARRAY but found STRING.", ([1, 0] : Array<Dynamic>)), r.expr("abc").do_(function(v:Expr):Expr return v.append(3)));
		@:await assertError(err("ReqlQueryLogicError", "Expected type STRING but found NUMBER.", ([1, 1] : Array<Dynamic>)), r.expr("abc").do_(function(v:Expr):Expr return v + 3));
		@:await assertError(err("ReqlQueryLogicError", "Expected type STRING but found NUMBER.", ([1] : Array<Dynamic>)), r.expr("abc").do_(function(v:Expr):Expr return v + "def") + 3);
		@:await assertError(err("ReqlQueryLogicError", "Expected function with 1 argument but found function with 2 arguments.", ([1] : Array<Dynamic>)), r.expr(0).do_(function(a:Expr, b:Expr):Expr return a + b));
		@:await assertError(err("ReqlQueryLogicError", "Expected function with 2 arguments but found function with 1 argument.", ([1] : Array<Dynamic>)), r.do_(1, 2, function(a:Expr):Expr return a));
		@:await assertAtom(5, r.expr(5).do_(r.row));
		@:await assertAtom(1, r.branch(true, 1, 2));
		@:await assertAtom(2, r.branch(false, 1, 2));
		@:await assertAtom(("c"), r.branch(1, "c", false));
		@:await assertAtom(([] : Array<Dynamic>), r.branch(null, {  }, ([] : Array<Dynamic>)));
		@:await assertError(err("ReqlQueryLogicError", "Expected type DATUM but found DATABASE:", ([] : Array<Dynamic>)), r.branch(r.db("test"), 1, 2));
		@:await assertError(err("ReqlQueryLogicError", "Expected type DATUM but found TABLE:", ([] : Array<Dynamic>)), r.branch(tbl, 1, 2));
		@:await assertError(err("ReqlUserError", "a", ([] : Array<Dynamic>)), r.branch(r.error("a"), 1, 2));
		@:await assertAtom(1, r.branch(([] : Array<Dynamic>), 1, 2));
		@:await assertAtom(1, r.branch({  }, 1, 2));
		@:await assertAtom(1, r.branch("a", 1, 2));
		@:await assertAtom(1, r.branch(1.2, 1, 2));
		@:await assertAtom(1, r.branch(true, 1, true, 2, 3));
		@:await assertAtom(1, r.branch(true, 1, false, 2, 3));
		@:await assertAtom(2, r.branch(false, 1, true, 2, 3));
		@:await assertAtom(3, r.branch(false, 1, false, 2, 3));
		@:await assertError(err("ReqlQueryLogicError", "Cannot call `branch` term with an even number of arguments."), r.branch(true, 1, true, 2));
		@:await assertError(err("ReqlUserError", "Hello World", ([0] : Array<Dynamic>)), r.error("Hello World"));
		@:await assertError(err("ReqlQueryLogicError", "Expected type STRING but found NUMBER.", ([0] : Array<Dynamic>)), r.error(5));
		@:await assertAtom(2, r.js("1 + 1"));
		@:await assertAtom(4, r.js("1 + 1; 2 + 2"));
		@:await assertAtom(3, r.do_(1, 2, r.js("(function(a, b) { return a + b; })")));
		@:await assertAtom(2, r.expr(1).do_(r.js("(function(x) { return x + 1; })")));
		@:await assertAtom("foobar", r.expr("foo").do_(r.js("(function(x) { return x + \"bar\"; })")));
		@:await assertAtom(3, r.js("1 + 2", { "timeout" : 1.2 }));
		@:await assertError(err("ReqlQueryLogicError", "Query result must be of type DATUM, GROUPED_DATA, or STREAM (got FUNCTION).", ([0] : Array<Dynamic>)), r.js("(function() { return 1; })"));
		@:await assertError(err("ReqlQueryLogicError", "SyntaxError: Unexpected token (", ([0] : Array<Dynamic>)), r.js("function() { return 1; }"));
		@:await assertAtom(1, r.do_(1, 2, r.js("(function(a) { return a; })")));
		@:await assertAtom(1, r.do_(1, 2, r.js("(function(a, b, c) { return a; })")));
		@:await assertError(err("ReqlQueryLogicError", "Cannot convert javascript `undefined` to ql::datum_t.", ([0] : Array<Dynamic>)), r.do_(1, 2, r.js("(function(a, b, c) { return c; })")));
		@:await assertAtom(([2, 3] : Array<Dynamic>), r.expr(([1, 2, 3] : Array<Dynamic>)).filter(r.js("(function(a) { return a >= 2; })")));
		@:await assertAtom(([2, 3, 4] : Array<Dynamic>), r.expr(([1, 2, 3] : Array<Dynamic>)).map(r.js("(function(a) { return a + 1; })")));
		@:await assertError(err("ReqlQueryLogicError", "Expected type FUNCTION but found DATUM:", ([0] : Array<Dynamic>)), r.expr(([1, 2, 3] : Array<Dynamic>)).map(r.js("1")));
		@:await assertError(err("ReqlQueryLogicError", "Cannot convert javascript `undefined` to ql::datum_t.", ([0] : Array<Dynamic>)), r.expr(([1, 2, 3] : Array<Dynamic>)).filter(r.js("(function(a) {})")));
		@:await assertError(err("ReqlQueryLogicError", "Expected type FUNCTION but found DATUM:", ([0] : Array<Dynamic>)), r.expr(([1, 2, 3] : Array<Dynamic>)).map(1));
		@:await assertAtom(([1, 2, 3] : Array<Dynamic>), r.expr(([1, 2, 3] : Array<Dynamic>)).filter("foo"));
		@:await assertAtom(([1, 2, 4] : Array<Dynamic>), r.expr(([1, 2, 4] : Array<Dynamic>)).filter(([] : Array<Dynamic>)));
		@:await assertAtom(([] : Array<Dynamic>), r.expr(([1, 2, 3] : Array<Dynamic>)).filter(null));
		@:await assertAtom(([] : Array<Dynamic>), r.expr(([1, 2, 4] : Array<Dynamic>)).filter(false));
		@:await assertAtom(0, tbl.count());
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 3 }), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(function(row:Expr):Expr return tbl.insert({ "id" : row })));
		@:await assertAtom(3, tbl.count());
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 9, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 0.0 }), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(function(row:Expr):Expr return tbl.update({ "foo" : row })));
		@:await assertAtom({ "first_error" : "Duplicate primary key `id`:\n{\n\t\"foo\":\t3,\n\t\"id\":\t1\n}\n{\n\t\"id\":\t1\n}", "deleted" : 0.0, "replaced" : 0.0, "unchanged" : 0.0, "errors" : 3, "skipped" : 0.0, "inserted" : 3 }, r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(function(row:Expr):Expr return ([tbl.insert({ "id" : row }), tbl.insert({ "id" : row * 10 })] : Array<Dynamic>)));
		@:await assertAtom(6, tbl.count());
		var tableCount = tbl2.count();
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "generated_keys" : arrlen(3, uuid()), "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 3 }), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(tbl2.insert({  })));
		@:await assertAtom(tableCount + 1, tbl2.count());
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 36, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 0.0 }), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(function(row:Expr):Expr return ([tbl.update({ "foo" : row }), tbl.update({ "bar" : row })] : Array<Dynamic>)));
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 3 }), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(tbl2.insert({ "id" : r.row })));
		@:await assertError(err("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", ([0] : Array<Dynamic>)), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(1));
		@:await assertError(err("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", ([1, 1] : Array<Dynamic>)), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(function(x:Expr):Expr return x));
		@:await assertError(err("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", ([1, 1] : Array<Dynamic>)), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(r.row));
		@:await assertError(err("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.", ([1, 1] : Array<Dynamic>)), r.expr(([1, 2, 3] : Array<Dynamic>)).forEach(function(row:Expr):Expr return tbl));
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "generated_keys" : arrlen(1, uuid()), "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 1 }), r.expr(1).do_(tbl.insert({ "foo" : r.row })));
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "generated_keys" : arrlen(1, uuid()), "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 1 }), r.expr(([1, 2] : Array<Dynamic>))[0].do_(tbl.insert({ "foo" : r.row })));
		@:await assertAtom(partial({ "tables_created" : 1 }), r.expr(1).do_(r.db("test").tableCreate("table_create_success")));
		@:await assertAtom(([1, 2] : Array<Dynamic>), r.expr(([1, 2] : Array<Dynamic>)));
		@:await dropTables(_tables);
		return Noise;
	}
}