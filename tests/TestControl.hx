package ;
import rethinkdb.RethinkDB.r;
import rethinkdb.reql.*;
using tink.CoreApi;

@:await class TestControl extends TestBase {
	@:async
	override function test() {
		var _tables = ["tbl", "tbl2"];
		@:await createTables(_tables);
		var tbl = r.db("test").table("tbl"), tbl2 = r.db("test").table("tbl2");
		@:await assertAtom(2, r.expr(1).do_(function(v) return v * 2));
		@:await assertAtom([0, 1, 2, 3], r.expr([0, 1, 2]).do_(function(v) return v.append(3)));
		@:await assertAtom(3, r.do_(1, 2, function(x, y) return x + y));
		@:await assertAtom(1, r.do_(function() return 1));
		@:await assertError("ReqlQueryLogicError", "Expected function with 2 arguments but found function with 1 argument.", r.do_(1, 2, function(x) return x));
		@:await assertError("ReqlQueryLogicError", "Expected function with 3 arguments but found function with 2 arguments.", r.do_(1, 2, 3, function(x, y) return x + y));
		@:await assertAtom(1, r.do_(1));
		@:await assertError("ReqlCompileError", "Expected 1 or more arguments but found 0.", r.do_());
		@:await assertError("ReqlQueryLogicError", "Expected type ARRAY but found STRING.", r.expr("abc").do_(function(v) return v.append(3)));
		@:await assertError("ReqlQueryLogicError", "Expected type STRING but found NUMBER.", r.expr("abc").do_(function(v) return v + 3));
		@:await assertError("ReqlQueryLogicError", "Expected type STRING but found NUMBER.", r.expr("abc").do_(function(v) return v + "def") + 3);
		@:await assertError("ReqlQueryLogicError", "Expected function with 1 argument but found function with 2 arguments.", r.expr(0).do_(function(a, b) return a + b));
		@:await assertError("ReqlQueryLogicError", "Expected function with 2 arguments but found function with 1 argument.", r.do_(1, 2, function(a) return a));
		@:await assertAtom(5, r.expr(5).do_(r.row));
		@:await assertAtom(1, r.branch(true, 1, 2));
		@:await assertAtom(2, r.branch(false, 1, 2));
		@:await assertAtom(("c"), r.branch(1, "c", false));
		@:await assertAtom(([]), r.branch(null, {  }, []));
		@:await assertError("ReqlQueryLogicError", "Expected type DATUM but found DATABASE:", r.branch(r.db("test"), 1, 2));
		@:await assertError("ReqlQueryLogicError", "Expected type DATUM but found TABLE:", r.branch(tbl, 1, 2));
		@:await assertError("ReqlUserError", "a", r.branch(r.error("a"), 1, 2));
		@:await assertAtom(1, r.branch([], 1, 2));
		@:await assertAtom(1, r.branch({  }, 1, 2));
		@:await assertAtom(1, r.branch("a", 1, 2));
		@:await assertAtom(1, r.branch(1.2, 1, 2));
		@:await assertAtom(1, r.branch(true, 1, true, 2, 3));
		@:await assertAtom(1, r.branch(true, 1, false, 2, 3));
		@:await assertAtom(2, r.branch(false, 1, true, 2, 3));
		@:await assertAtom(3, r.branch(false, 1, false, 2, 3));
		@:await assertError("ReqlQueryLogicError", "Cannot call `branch` term with an even number of arguments.", r.branch(true, 1, true, 2));
		@:await assertError("ReqlUserError", "Hello World", r.error("Hello World"));
		@:await assertError("ReqlQueryLogicError", "Expected type STRING but found NUMBER.", r.error(5));
		@:await assertError("ReqlCompileError", "Expected 2 arguments but found 1.", r.expr([1, 2, 3]).filter());
		@:await assertError("ReqlCompileError", "Expected 2 arguments but found 3.", r.expr([1, 2, 3]).filter(1, 2));
		@:await assertAtom(2, r.js("1 + 1"));
		@:await assertAtom(4, r.js("1 + 1; 2 + 2"));
		@:await assertAtom(3, r.do_(1, 2, r.js("(function(a, b) { return a + b; })")));
		@:await assertAtom(2, r.expr(1).do_(r.js("(function(x) { return x + 1; })")));
		@:await assertAtom("foobar", r.expr("foo").do_(r.js("(function(x) { return x + \"bar\"; })")));
		@:await assertAtom(3, r.js("1 + 2", { "timeout" : 1.2 }));
		@:await assertError("ReqlQueryLogicError", "Query result must be of type DATUM, GROUPED_DATA, or STREAM (got FUNCTION).", r.js("(function() { return 1; })"));
		@:await assertError("ReqlQueryLogicError", "SyntaxError: Unexpected token (", r.js("function() { return 1; }"));
		@:await assertAtom(1, r.do_(1, 2, r.js("(function(a) { return a; })")));
		@:await assertAtom(1, r.do_(1, 2, r.js("(function(a, b, c) { return a; })")));
		@:await assertError("ReqlQueryLogicError", "Cannot convert javascript `undefined` to ql::datum_t.", r.do_(1, 2, r.js("(function(a, b, c) { return c; })")));
		@:await assertAtom(([2, 3]), r.expr([1, 2, 3]).filter(r.js("(function(a) { return a >= 2; })")));
		@:await assertAtom(([2, 3, 4]), r.expr([1, 2, 3]).map(r.js("(function(a) { return a + 1; })")));
		@:await assertError("ReqlQueryLogicError", "Expected type FUNCTION but found DATUM:", r.expr([1, 2, 3]).map(r.js("1")));
		@:await assertError("ReqlQueryLogicError", "Cannot convert javascript `undefined` to ql::datum_t.", r.expr([1, 2, 3]).filter(r.js("(function(a) {})")));
		@:await assertError("ReqlQueryLogicError", "Expected type FUNCTION but found DATUM:", r.expr([1, 2, 3]).map(1));
		@:await assertAtom(([1, 2, 3]), r.expr([1, 2, 3]).filter("foo"));
		@:await assertAtom(([1, 2, 4]), r.expr([1, 2, 4]).filter([]));
		@:await assertAtom(([]), r.expr([1, 2, 3]).filter(null));
		@:await assertAtom(([]), r.expr([1, 2, 4]).filter(false));
		@:await assertAtom(0, tbl.count());
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 3 }), r.expr([1, 2, 3]).forEach(function(row) return tbl.insert({ "id" : row })));
		@:await assertAtom(3, tbl.count());
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 9, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 0.0 }), r.expr([1, 2, 3]).forEach(function(row) return tbl.update({ "foo" : row })));
		@:await assertAtom({ "first_error" : "Duplicate primary key `id`:\n{\n\t\"foo\":\t3,\n\t\"id\":\t1\n}\n{\n\t\"id\":\t1\n}", "deleted" : 0.0, "replaced" : 0.0, "unchanged" : 0.0, "errors" : 3, "skipped" : 0.0, "inserted" : 3 }, r.expr([1, 2, 3]).forEach(function(row) return [tbl.insert({ "id" : row }), tbl.insert({ "id" : row * 10 })]));
		@:await assertAtom(6, tbl.count());
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "generated_keys" : arrlen(3, uuid()), "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 3 }), r.expr([1, 2, 3]).forEach(tbl2.insert({  })));
		@:await assertAtom(tableCount + 1, tbl2.count());
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 36, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 0.0 }), r.expr([1, 2, 3]).forEach(function(row) return [tbl.update({ "foo" : row }), tbl.update({ "bar" : row })]));
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 3 }), r.expr([1, 2, 3]).forEach(tbl2.insert({ "id" : r.row })));
		@:await assertError("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", r.expr([1, 2, 3]).forEach(1));
		@:await assertError("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", r.expr([1, 2, 3]).forEach(function(x) return x));
		@:await assertError("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", r.expr([1, 2, 3]).forEach(r.row));
		@:await assertError("ReqlQueryLogicError", "FOR_EACH expects one or more basic write queries.", r.expr([1, 2, 3]).forEach(function(row) return tbl));
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "generated_keys" : arrlen(1, uuid()), "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 1 }), r.expr(1).do_(tbl.insert({ "foo" : r.row })));
		@:await assertAtom(({ "deleted" : 0.0, "replaced" : 0.0, "generated_keys" : arrlen(1, uuid()), "unchanged" : 0.0, "errors" : 0.0, "skipped" : 0.0, "inserted" : 1 }), r.expr([1, 2])[0].do_(tbl.insert({ "foo" : r.row })));
		@:await assertError("ReqlCompileError", "Cannot nest writes or meta ops in stream operations.  Use FOR_EACH instead.", r.expr([1, 2]).map(tbl.insert({ "foo" : r.row })));
		@:await assertError("ReqlCompileError", "Cannot nest writes or meta ops in stream operations.  Use FOR_EACH instead.", r.expr([1, 2]).map(r.db("test").tableCreate("table_create_failure")));
		@:await assertError("ReqlCompileError", "Cannot nest writes or meta ops in stream operations.  Use FOR_EACH instead.", r.expr([1, 2]).map(tbl.insert({ "foo" : r.row }).getField("inserted")));
		@:await assertError("ReqlCompileError", "Cannot nest writes or meta ops in stream operations.  Use FOR_EACH instead.", r.expr([1, 2]).map(tbl.insert({ "foo" : r.row }).getField("inserted").add(5)));
		@:await assertPartial({ "tables_created" : 1 }, r.expr(1).do_(r.db("test").tableCreate("table_create_success")));
		@:await assertAtom([1, 2], r.expr([1, 2]));
		@:await dropTables(_tables);
		return Noise;
	}
}