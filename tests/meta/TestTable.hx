package meta;
import rethinkdb.RethinkDB.r;
import rethinkdb.reql.*;
using tink.CoreApi;

@:await class TestTable extends TestBase {
	@:async
	override function test() {
		var db = r.db("test");
		@:await assertAtom(([] : Array<Dynamic>), db.tableList());
		@:await assertAtom(({ "type" : "DB", "name" : "rethinkdb", "id" : uuid() }), r.db("rethinkdb").info());
		@:await assertAtom(partial({ "db" : { "type" : "DB", "name" : "rethinkdb", "id" : uuid() }, "type" : "TABLE", "id" : uuid(), "name" : "stats", "indexes" : ([] : Array<Dynamic>), "primary_key" : "id" }), r.db("rethinkdb").table("stats").info());
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("a"));
		@:await assertAtom((["a"] : Array<Dynamic>), db.tableList());
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("b"));
		@:await assertAtom(bag((["a", "b"] : Array<Dynamic>)), db.tableList());
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("a"));
		@:await assertAtom((["b"] : Array<Dynamic>), db.tableList());
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("b"));
		@:await assertAtom(([] : Array<Dynamic>), db.tableList());
		@:await assertAtom(partial({ "tables_created" : 1, "config_changes" : ([partial({ "new_val" : partial({ "durability" : "soft" }) })] : Array<Dynamic>) }), db.tableCreate("ab", { "durability" : "soft" }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("ab"));
		@:await assertAtom(partial({ "tables_created" : 1, "config_changes" : ([partial({ "new_val" : partial({ "durability" : "hard" }) })] : Array<Dynamic>) }), db.tableCreate("ab", { "durability" : "hard" }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("ab"));
		@:await assertError(err("ReqlQueryLogicError", "Durability option `fake` unrecognized (options are \"hard\" and \"soft\")."), db.tableCreate("ab", { "durability" : "fake" }));
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("ab", { "primary_key" : "bar", "shards" : 2, "replicas" : 1 }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("ab"));
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("ab", { "primary_key" : "bar", "primary_replica_tag" : "default" }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("ab"));
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("ab", { "nonvoting_replica_tags" : (["default"] : Array<Dynamic>) }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("ab"));
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("a"));
		@:await assertAtom(partial({ "reconfigured" : 1 }), db.table("a").reconfigure({ "shards" : 1, "replicas" : 1 }));
		@:await assertAtom(partial({ "reconfigured" : 1 }), db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 1 }, "nonvoting_replica_tags" : (["default"] : Array<Dynamic>), "primary_replica_tag" : "default" }));
		@:await assertAtom(partial({ "reconfigured" : 0 }), db.table("a").reconfigure({ "shards" : 1, "replicas" : 1, "dry_run" : true }));
		@:await assertError(err("ReqlOpFailedError", "This table doesn\'t need to be repaired.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback" }));
		@:await assertError(err("ReqlOpFailedError", "This table doesn\'t need to be repaired.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback", "dry_run" : true }));
		@:await assertError(err("ReqlOpFailedError", "This table doesn\'t need to be repaired.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback_or_erase" }));
		@:await assertAtom(partial({ "reconfigured" : 0 }), db.table("a").reconfigure({ "emergency_repair" : null, "shards" : 1, "replicas" : 1, "dry_run" : true }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("a"));
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("foo"));
		@:await assertError(err("ReqlOpFailedError", "Table `test.foo` already exists.", ([0] : Array<Dynamic>)), db.tableCreate("foo"));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("foo"));
		@:await assertError(err("ReqlOpFailedError", "Table `test.foo` does not exist.", ([0] : Array<Dynamic>)), db.tableDrop("foo"));
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("a"));
		@:await assertError(err("ReqlQueryLogicError", "Every table must have at least one shard.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 0, "replicas" : 1 }));
		@:await assertError(err("ReqlOpFailedError", "Can\'t use server tag `foo` for primary replicas because you specified no replicas in server tag `foo`.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 1 }, "primary_replica_tag" : "foo" }));
		@:await assertError(err("ReqlOpFailedError", "You specified that the replicas in server tag `foo` should be non-voting, but you didn\'t specify a number of replicas in server tag `foo`.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 1 }, "primary_replica_tag" : "default", "nonvoting_replica_tags" : (["foo"] : Array<Dynamic>) }));
		@:await assertError(err("ReqlOpFailedError", "You must set `replicas` to at least one. `replicas` includes the primary replica; if there are zero replicas, there is nowhere to put the data.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : { "foo" : 0 }, "primary_replica_tag" : "foo" }));
		@:await assertError(err("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 0 } }));
		@:await assertError(err("ReqlQueryLogicError", "Can\'t have a negative number of replicas", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : -3 }, "primary_replica_tag" : "default" }));
		@:await assertError(err("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : 3, "primary_replica_tag" : "foo" }));
		@:await assertError(err("ReqlQueryLogicError", "`replicas` must be an OBJECT if `nonvoting_replica_tags` is specified.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : 3, "nonvoting_replica_tags" : (["foo"] : Array<Dynamic>) }));
		@:await assertError(err("ReqlQueryLogicError", "Can\'t emergency repair an entire database at once; instead you should run `reconfigure()` on each table individually."), db.reconfigure({ "emergency_repair" : "unsafe_rollback" }));
		@:await assertError(err("ReqlQueryLogicError", "`emergency_repair` should be \"unsafe_rollback\" or \"unsafe_rollback_or_erase\"", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "emergency_repair" : "foo" }));
		@:await assertError(err("ReqlQueryLogicError", "In emergency repair mode, you can\'t specify shards, replicas, etc."), db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback", "shards" : 1, "replicas" : 1 }));
		@:await assertAtom(partial({ "reconfigured" : 1 }), db.table("a").reconfigure({ "shards" : 2, "replicas" : 1 }));
		@:await assertAtom({ "ready" : 1 }, db.table("a").wait({ "wait_for" : "all_replicas_ready" }));
		@:await assertAtom(partial({ "inserted" : 4 }), db.table("a").insert(([{ "id" : 1 }, { "id" : 2 }, { "id" : 3 }, { "id" : 4 }] : Array<Dynamic>)));
		@:await assertAtom(partial({ "reconfigured" : 1 }), db.table("a").reconfigure({ "shards" : 2, "replicas" : 1 }));
		@:await assertError(err("ReqlOpFailedError", "Can\'t put 2 replicas on servers with the tag `default` because there are only 1 servers with the tag `default`. It\'s impossible to have more replicas of the data than there are servers.", ([] : Array<Dynamic>)), db.table("a").reconfigure({ "shards" : 1, "replicas" : 2 }));
		@:await assertAtom({ "ready" : 1 }, db.table("a").wait({ "wait_for" : "all_replicas_ready" }));
		@:await assertAtom(partial({ "rebalanced" : 1 }), db.table("a").rebalance());
		@:await assertAtom({ "ready" : 1 }, db.wait({ "wait_for" : "all_replicas_ready" }));
		@:await assertAtom(partial({ "rebalanced" : 1 }), db.rebalance());
		@:await assertError(err("AttributeError", "\'module\' object has no attribute \'wait\'", ([] : Array<Dynamic>)), r.wait());
		@:await assertError(err("AttributeError", "\'module\' object has no attribute \'rebalance\'", ([] : Array<Dynamic>)), r.rebalance());
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("a"));
		db.tableCreate("a");
		db.tableCreate("b");
		db.tableCreate("c");
		@:await assertError(err("ReqlQueryLogicError", "Every table must have at least one shard.", ([] : Array<Dynamic>)), db.reconfigure({ "shards" : 0, "replicas" : 1 }));
		@:await assertError(err("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", ([] : Array<Dynamic>)), db.reconfigure({ "shards" : 1, "replicas" : { "default" : 0 } }));
		@:await assertError(err("ReqlQueryLogicError", "Can\'t have a negative number of replicas", ([] : Array<Dynamic>)), db.reconfigure({ "shards" : 1, "replicas" : { "default" : -3 }, "primary_replica_tag" : "default" }));
		@:await assertError(err("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", ([] : Array<Dynamic>)), db.reconfigure({ "shards" : 1, "replicas" : 3, "primary_replica_tag" : "foo" }));
		@:await assertAtom(partial({ "reconfigured" : 3 }), db.reconfigure({ "shards" : 2, "replicas" : 1 }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("a"));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("b"));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("c"));
		@:await assertAtom(partial({ "dbs_created" : 1 }), r.dbCreate("test2"));
		var db2 = r.db("test2");
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("testA"));
		@:await assertAtom(partial({ "tables_created" : 1 }), db.tableCreate("testB"));
		@:await assertAtom(partial({ "tables_created" : 1 }), db2.tableCreate("test2B"));
		@:await assertAtom({ "db" : "test", "name" : "testA" }, r.table("testA").config().pluck("db", "name"));
		@:await assertError(err("ReqlOpFailedError", "Table `test.doesntexist` does not exist.", ([] : Array<Dynamic>)), r.table("doesntexist").config());
		@:await assertError(err("ReqlOpFailedError", "Table `test.test2B` does not exist.", ([] : Array<Dynamic>)), r.table("test2B").config());
		@:await assertAtom(true, r.db("rethinkdb").table("table_config").filter({ "name" : "testA" }).nth(0).eq(r.table("testA").config()));
		@:await assertAtom(true, r.db("rethinkdb").table("table_status").filter({ "name" : "testA" }).nth(0).eq(r.table("testA").status()));
		@:await assertAtom(uuid(), r.db("rethinkdb").table("table_config", { "identifier_format" : "uuid" }).nth(0)["db"]);
		@:await assertAtom(0, r.table("testA", { "identifier_format" : "uuid" }).count());
		@:await assertError(err("AttributeError", "\'module\' object has no attribute \'wait\'", ([] : Array<Dynamic>)), r.wait({ "wait_for" : "all_replicas_ready", "timeout" : 5 }));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("testA"));
		@:await assertAtom(partial({ "tables_dropped" : 1 }), db.tableDrop("testB"));
		@:await assertAtom(partial({ "dbs_dropped" : 1, "tables_dropped" : 1 }), r.dbDrop("test2"));
		return Noise;
	}
}