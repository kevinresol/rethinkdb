package meta;
import rethinkdb.RethinkDB.r;
import rethinkdb.reql.*;
class TestTable extends TestBase {
	override function test() {
		var db = r.db("test");
		assertAtom([], db.tableList());
		assertAtom(({ type : "DB", name : "rethinkdb", id : uuid() }), r.db("rethinkdb").info());
		assertAtom(partial({ db : { type : "DB", name : "rethinkdb", id : uuid() }, type : "TABLE", id : uuid(), name : "stats", indexes : [], primary_key : "id" }), r.db("rethinkdb").table("stats").info());
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("a"));
		assertAtom([a], db.tableList());
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("b"));
		assertAtom(bag(["a", "b"]), db.tableList());
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("a"));
		assertAtom([b], db.tableList());
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("b"));
		assertAtom([], db.tableList());
		assertAtom(partial({ tables_created : 1, config_changes : [partial({ new_val : partial({ durability : "soft" }) })] }), db.tableCreate("ab", { "durability" : "soft" }));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("ab"));
		assertAtom(partial({ tables_created : 1, config_changes : [partial({ new_val : partial({ durability : "hard" }) })] }), db.tableCreate("ab", { "durability" : "hard" }));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("ab"));
		assertError("ReqlQueryLogicError", "Durability option `fake` unrecognized (options are \"hard\" and \"soft\").", db.tableCreate("ab", { "durability" : "fake" }));
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("ab", { "primary_key" : "bar", "shards" : 2, "replicas" : 1 }));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("ab"));
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("ab", { "primary_key" : "bar", "primary_replica_tag" : "default" }));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("ab"));
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("ab", { "nonvoting_replica_tags" : ["default"] }));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("ab"));
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("a"));
		assertAtom(partial({ reconfigured : 1 }), db.table("a").reconfigure({ "shards" : 1, "replicas" : 1 }));
		assertAtom(partial({ reconfigured : 1 }), db.table("a").reconfigure({ "shards" : 1, "replicas" : { default : 1 }, "nonvoting_replica_tags" : ["default"], "primary_replica_tag" : "default" }));
		assertError("ReqlOpFailedError", "This table doesn\'t need to be repaired.", db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback" }));
		assertError("ReqlOpFailedError", "This table doesn\'t need to be repaired.", db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback_or_erase" }));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("a"));
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("foo"));
		assertError("ReqlOpFailedError", "Table `test.foo` already exists.", db.tableCreate("foo"));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("foo"));
		assertError("ReqlOpFailedError", "Table `test.foo` does not exist.", db.tableDrop("foo"));
		assertError("ReqlCompileError", "Unrecognized optional argument `foo`.", db.tableCreate("nonsense", { "foo" : "bar" }));
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("a"));
		assertError("ReqlQueryLogicError", "Every table must have at least one shard.", db.table("a").reconfigure({ "shards" : 0, "replicas" : 1 }));
		assertError("ReqlOpFailedError", "Can\'t use server tag `foo` for primary replicas because you specified no replicas in server tag `foo`.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { default : 1 }, "primary_replica_tag" : "foo" }));
		assertError("ReqlOpFailedError", "You specified that the replicas in server tag `foo` should be non-voting, but you didn\'t specify a number of replicas in server tag `foo`.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { default : 1 }, "primary_replica_tag" : "default", "nonvoting_replica_tags" : ["foo"] }));
		assertError("ReqlOpFailedError", "You must set `replicas` to at least one. `replicas` includes the primary replica; if there are zero replicas, there is nowhere to put the data.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { foo : 0 }, "primary_replica_tag" : "foo" }));
		assertError("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { default : 0 } }));
		assertError("ReqlQueryLogicError", "Can\'t have a negative number of replicas", db.table("a").reconfigure({ "shards" : 1, "replicas" : { default : -3 }, "primary_replica_tag" : "default" }));
		assertError("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", db.table("a").reconfigure({ "shards" : 1, "replicas" : 3, "primary_replica_tag" : "foo" }));
		assertError("ReqlQueryLogicError", "`replicas` must be an OBJECT if `nonvoting_replica_tags` is specified.", db.table("a").reconfigure({ "shards" : 1, "replicas" : 3, "nonvoting_replica_tags" : ["foo"] }));
		assertError("ReqlQueryLogicError", "Can\'t emergency repair an entire database at once; instead you should run `reconfigure()` on each table individually.", db.reconfigure({ "emergency_repair" : "unsafe_rollback" }));
		assertError("ReqlQueryLogicError", "`emergency_repair` should be \"unsafe_rollback\" or \"unsafe_rollback_or_erase\"", db.table("a").reconfigure({ "emergency_repair" : "foo" }));
		assertError("ReqlQueryLogicError", "In emergency repair mode, you can\'t specify shards, replicas, etc.", db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback", "shards" : 1, "replicas" : 1 }));
		assertAtom(partial({ reconfigured : 1 }), db.table("a").reconfigure({ "shards" : 2, "replicas" : 1 }));
		assertAtom(partial({ inserted : 4 }), db.table("a").insert([{ id : 1 }, { id : 2 }, { id : 3 }, { id : 4 }]));
		assertAtom(partial({ reconfigured : 1 }), db.table("a").reconfigure({ "shards" : 2, "replicas" : 1 }));
		assertError("ReqlOpFailedError", "Can\'t put 2 replicas on servers with the tag `default` because there are only 1 servers with the tag `default`. It\'s impossible to have more replicas of the data than there are servers.", db.table("a").reconfigure({ "shards" : 1, "replicas" : 2 }));
		assertAtom(partial({ rebalanced : 1 }), db.table("a").rebalance());
		assertAtom(partial({ rebalanced : 1 }), db.rebalance());
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("a"));
		assertAtom(null, db.tableCreate("a"));
		assertAtom(null, db.tableCreate("b"));
		assertAtom(null, db.tableCreate("c"));
		assertError("ReqlQueryLogicError", "Every table must have at least one shard.", db.reconfigure({ "shards" : 0, "replicas" : 1 }));
		assertError("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", db.reconfigure({ "shards" : 1, "replicas" : { default : 0 } }));
		assertError("ReqlQueryLogicError", "Can\'t have a negative number of replicas", db.reconfigure({ "shards" : 1, "replicas" : { default : -3 }, "primary_replica_tag" : "default" }));
		assertError("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", db.reconfigure({ "shards" : 1, "replicas" : 3, "primary_replica_tag" : "foo" }));
		assertAtom(partial({ reconfigured : 3 }), db.reconfigure({ "shards" : 2, "replicas" : 1 }));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("a"));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("b"));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("c"));
		assertAtom(partial({ dbs_created : 1 }), r.dbCreate("test2"));
		var db2 = r.db("test2");
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("testA"));
		assertAtom(partial({ tables_created : 1 }), db.tableCreate("testB"));
		assertAtom(partial({ tables_created : 1 }), db2.tableCreate("test2B"));
		assertError("ReqlOpFailedError", "Table `test.doesntexist` does not exist.", r.table("doesntexist").config());
		assertError("ReqlOpFailedError", "Table `test.test2B` does not exist.", r.table("test2B").config());
		assertAtom(true, r.db("rethinkdb").table("table_config").filter({ name : "testA" }).nth(0).eq(r.table("testA").config()));
		assertAtom(true, r.db("rethinkdb").table("table_status").filter({ name : "testA" }).nth(0).eq(r.table("testA").status()));
		assertAtom(uuid(), r.db("rethinkdb").table("table_config", { "identifier_format" : "uuid" }).nth(0)["db"]);
		assertAtom(0, r.table("testA", { "identifier_format" : "uuid" }).count());
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("testA"));
		assertAtom(partial({ tables_dropped : 1 }), db.tableDrop("testB"));
		assertAtom(partial({ dbs_dropped : 1, tables_dropped : 1 }), r.dbDrop("test2"));
	}
}