package meta;
import rethinkdb.RethinkDB.r;
import rethinkdb.reql.*;
using tink.CoreApi;

@:await class TestTable extends TestBase {
	@:async
	override function test() {
		var db = r.db("test");
		@:await assertAtom([], db.tableList());
		@:await assertAtom(({ "type" : "DB", "name" : "rethinkdb", "id" : uuid() }), r.db("rethinkdb").info());
		@:await assertPartial({ "db" : { "type" : "DB", "name" : "rethinkdb", "id" : uuid() }, "type" : "TABLE", "id" : uuid(), "name" : "stats", "indexes" : [], "primary_key" : "id" }, r.db("rethinkdb").table("stats").info());
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("a"));
		@:await assertAtom(["a"], db.tableList());
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("b"));
		@:await assertBag(["a", "b"], db.tableList());
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("a"));
		@:await assertAtom(["b"], db.tableList());
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("b"));
		@:await assertAtom([], db.tableList());
		@:await assertPartial({ "tables_created" : 1, "config_changes" : [partial({ "new_val" : partial({ "durability" : "soft" }) })] }, db.tableCreate("ab", { "durability" : "soft" }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("ab"));
		@:await assertPartial({ "tables_created" : 1, "config_changes" : [partial({ "new_val" : partial({ "durability" : "hard" }) })] }, db.tableCreate("ab", { "durability" : "hard" }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("ab"));
		@:await assertError("ReqlQueryLogicError", "Durability option `fake` unrecognized (options are \"hard\" and \"soft\").", db.tableCreate("ab", { "durability" : "fake" }));
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("ab", { "primary_key" : "bar", "shards" : 2, "replicas" : 1 }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("ab"));
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("ab", { "primary_key" : "bar", "primary_replica_tag" : "default" }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("ab"));
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("ab", { "nonvoting_replica_tags" : ["default"] }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("ab"));
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("a"));
		@:await assertPartial({ "reconfigured" : 1 }, db.table("a").reconfigure({ "shards" : 1, "replicas" : 1 }));
		@:await assertPartial({ "reconfigured" : 1 }, db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 1 }, "nonvoting_replica_tags" : ["default"], "primary_replica_tag" : "default" }));
		@:await assertPartial({ "reconfigured" : 0 }, db.table("a").reconfigure({ "shards" : 1, "replicas" : 1, "dry_run" : true }));
		@:await assertError("ReqlOpFailedError", "This table doesn\'t need to be repaired.", db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback" }));
		@:await assertError("ReqlOpFailedError", "This table doesn\'t need to be repaired.", db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback", "dry_run" : true }));
		@:await assertError("ReqlOpFailedError", "This table doesn\'t need to be repaired.", db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback_or_erase" }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("a"));
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("foo"));
		@:await assertError("ReqlOpFailedError", "Table `test.foo` already exists.", db.tableCreate("foo"));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("foo"));
		@:await assertError("ReqlOpFailedError", "Table `test.foo` does not exist.", db.tableDrop("foo"));
		@:await assertError("ReqlCompileError", "Expected between 1 and 2 arguments but found 3.", db.tableCreate("nonsense", "foo"));
		@:await assertError("ReqlCompileError", "Unrecognized optional argument `foo`.", db.tableCreate("nonsense", { "foo" : "bar" }));
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("a"));
		@:await assertError("ReqlQueryLogicError", "Every table must have at least one shard.", db.table("a").reconfigure({ "shards" : 0, "replicas" : 1 }));
		@:await assertError("ReqlOpFailedError", "Can\'t use server tag `foo` for primary replicas because you specified no replicas in server tag `foo`.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 1 }, "primary_replica_tag" : "foo" }));
		@:await assertError("ReqlOpFailedError", "You specified that the replicas in server tag `foo` should be non-voting, but you didn\'t specify a number of replicas in server tag `foo`.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 1 }, "primary_replica_tag" : "default", "nonvoting_replica_tags" : ["foo"] }));
		@:await assertError("ReqlOpFailedError", "You must set `replicas` to at least one. `replicas` includes the primary replica; if there are zero replicas, there is nowhere to put the data.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { "foo" : 0 }, "primary_replica_tag" : "foo" }));
		@:await assertError("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : 0 } }));
		@:await assertError("ReqlQueryLogicError", "Can\'t have a negative number of replicas", db.table("a").reconfigure({ "shards" : 1, "replicas" : { "default" : -3 }, "primary_replica_tag" : "default" }));
		@:await assertError("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", db.table("a").reconfigure({ "shards" : 1, "replicas" : 3, "primary_replica_tag" : "foo" }));
		@:await assertError("ReqlQueryLogicError", "`replicas` must be an OBJECT if `nonvoting_replica_tags` is specified.", db.table("a").reconfigure({ "shards" : 1, "replicas" : 3, "nonvoting_replica_tags" : ["foo"] }));
		@:await assertError("ReqlQueryLogicError", "Can\'t emergency repair an entire database at once; instead you should run `reconfigure()` on each table individually.", db.reconfigure({ "emergency_repair" : "unsafe_rollback" }));
		@:await assertError("ReqlQueryLogicError", "`emergency_repair` should be \"unsafe_rollback\" or \"unsafe_rollback_or_erase\"", db.table("a").reconfigure({ "emergency_repair" : "foo" }));
		@:await assertError("ReqlQueryLogicError", "In emergency repair mode, you can\'t specify shards, replicas, etc.", db.table("a").reconfigure({ "emergency_repair" : "unsafe_rollback", "shards" : 1, "replicas" : 1 }));
		@:await assertPartial({ "reconfigured" : 1 }, db.table("a").reconfigure({ "shards" : 2, "replicas" : 1 }));
		@:await assertAtom({ "ready" : 1 }, db.table("a").wait({ "wait_for" : "all_replicas_ready" }));
		@:await assertPartial({ "inserted" : 4 }, db.table("a").insert([{ "id" : 1 }, { "id" : 2 }, { "id" : 3 }, { "id" : 4 }]));
		@:await assertPartial({ "reconfigured" : 1 }, db.table("a").reconfigure({ "shards" : 2, "replicas" : 1 }));
		@:await assertError("ReqlOpFailedError", "Can\'t put 2 replicas on servers with the tag `default` because there are only 1 servers with the tag `default`. It\'s impossible to have more replicas of the data than there are servers.", db.table("a").reconfigure({ "shards" : 1, "replicas" : 2 }));
		@:await assertAtom({ "ready" : 1 }, db.table("a").wait({ "wait_for" : "all_replicas_ready" }));
		@:await assertPartial({ "rebalanced" : 1 }, db.table("a").rebalance());
		@:await assertAtom({ "ready" : 1 }, db.wait({ "wait_for" : "all_replicas_ready" }));
		@:await assertPartial({ "rebalanced" : 1 }, db.rebalance());
		@:await assertError("AttributeError", "\'module\' object has no attribute \'wait\'", r.wait());
		@:await assertError("AttributeError", "\'module\' object has no attribute \'rebalance\'", r.rebalance());
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("a"));
		@:await assertError("ReqlQueryLogicError", "Every table must have at least one shard.", db.reconfigure({ "shards" : 0, "replicas" : 1 }));
		@:await assertError("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", db.reconfigure({ "shards" : 1, "replicas" : { "default" : 0 } }));
		@:await assertError("ReqlQueryLogicError", "Can\'t have a negative number of replicas", db.reconfigure({ "shards" : 1, "replicas" : { "default" : -3 }, "primary_replica_tag" : "default" }));
		@:await assertError("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", db.reconfigure({ "shards" : 1, "replicas" : 3, "primary_replica_tag" : "foo" }));
		@:await assertPartial({ "reconfigured" : 3 }, db.reconfigure({ "shards" : 2, "replicas" : 1 }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("a"));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("b"));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("c"));
		@:await assertPartial({ "dbs_created" : 1 }, r.dbCreate("test2"));
		var db2 = r.db("test2");
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("testA"));
		@:await assertPartial({ "tables_created" : 1 }, db.tableCreate("testB"));
		@:await assertPartial({ "tables_created" : 1 }, db2.tableCreate("test2B"));
		@:await assertAtom({ "db" : "test", "name" : "testA" }, r.table("testA").config().pluck("db", "name"));
		@:await assertError("ReqlOpFailedError", "Table `test.doesntexist` does not exist.", r.table("doesntexist").config());
		@:await assertError("ReqlOpFailedError", "Table `test.test2B` does not exist.", r.table("test2B").config());
		@:await assertAtom(true, r.db("rethinkdb").table("table_config").filter({ "name" : "testA" }).nth(0).eq(r.table("testA").config()));
		@:await assertAtom(true, r.db("rethinkdb").table("table_status").filter({ "name" : "testA" }).nth(0).eq(r.table("testA").status()));
		@:await assertAtom(uuid(), r.db("rethinkdb").table("table_config", { "identifier_format" : "uuid" }).nth(0)["db"]);
		@:await assertAtom(0, r.table("testA", { "identifier_format" : "uuid" }).count());
		@:await assertError("AttributeError", "\'module\' object has no attribute \'wait\'", r.wait({ "wait_for" : "all_replicas_ready", "timeout" : 5 }));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("testA"));
		@:await assertPartial({ "tables_dropped" : 1 }, db.tableDrop("testB"));
		@:await assertPartial({ "dbs_dropped" : 1, "tables_dropped" : 1 }, r.dbDrop("test2"));
		return Noise;
	}
}