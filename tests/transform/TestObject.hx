package transform;
import rethinkdb.RethinkDB.r;
import rethinkdb.reql.*;
class TestObject extends TestBase {
	override function test() {
		var obj = r.expr({ "a" : 1, "b" : 2, "c" : "str", "d" : null, "e" : { "f" : "buzz" } });
		assertAtom(1, obj["a"]);
		assertAtom("str", obj["c"]);
		assertAtom(true, obj.hasFields("b"));
		assertAtom(true, obj.keys().contains("d"));
		assertAtom(false, obj.hasFields("d"));
		assertAtom(true, obj.hasFields({ "e" : "f" }));
		assertAtom(false, obj.hasFields({ "e" : "g" }));
		assertAtom(false, obj.hasFields("f"));
		assertAtom(true, obj.hasFields("a", "b"));
		assertAtom(false, obj.hasFields("a", "d"));
		assertAtom(false, obj.hasFields("a", "f"));
		assertAtom(true, obj.hasFields("a", { "e" : "f" }));
		assertAtom(2, r.expr([obj, obj.pluck("a", "b")]).hasFields("a", "b").count());
		assertAtom(1, r.expr([obj, obj.pluck("a", "b")]).hasFields("a", "c").count());
		assertAtom(2, r.expr([obj, obj.pluck("a", "e")]).hasFields("a", { "e" : "f" }).count());
		assertAtom({ "a" : 1 }, obj.pluck("a"));
		assertAtom({ "a" : 1, "b" : 2 }, obj.pluck("a", "b"));
		assertAtom({ "b" : 2, "c" : "str", "d" : null, "e" : { "f" : "buzz" } }, obj.without("a"));
		assertAtom({ "c" : "str", "d" : null, "e" : { "f" : "buzz" } }, obj.without("a", "b"));
		assertAtom({ "e" : { "f" : "buzz" } }, obj.without("a", "b", "c", "d"));
		assertAtom({ "a" : 1, "b" : 2, "c" : "str", "d" : null, "e" : {  } }, obj.without({ "e" : "f" }));
		assertAtom({ "a" : 1, "b" : 2, "c" : "str", "d" : null, "e" : { "f" : "buzz" } }, obj.without({ "e" : "buzz" }));
		assertAtom(1, obj.merge(1));
		assertAtom({ "a" : 1, "b" : 2, "c" : "str", "d" : null, "e" : -2 }, obj.merge({ "e" : -2 }));
		assertAtom({ "a" : 1, "b" : 2, "c" : "str", "d" : null }, obj.merge({ "e" : r.literal() }));
		assertAtom({ "a" : 1, "b" : 2, "c" : "str", "d" : null, "e" : { "f" : "quux" } }, obj.merge({ "e" : { "f" : "quux" } }));
		assertAtom({ "a" : 1, "b" : 2, "c" : "str", "d" : null, "e" : { "f" : "buzz", "g" : "quux" } }, obj.merge({ "e" : { "g" : "quux" } }));
		assertAtom({ "a" : 1, "b" : 2, "c" : "str", "d" : null, "e" : { "g" : "quux" } }, obj.merge({ "e" : r.literal({ "g" : "quux" }) }));
		assertAtom({ "a" : -1, "b" : 2, "c" : "str", "d" : null, "e" : { "f" : "buzz" } }, obj.merge({ "a" : -1 }));
		var errmsg = "Stray literal keyword found:" + " literal is only legal inside of the object passed to merge or update and cannot nest inside other literals.";
		assertError("ReqlQueryLogicError", errmsg, r.literal("foo"));
		assertError("ReqlQueryLogicError", errmsg, obj.merge(r.literal("foo")));
		assertError("ReqlQueryLogicError", errmsg, obj.merge({ "foo" : r.literal(r.literal("foo")) }));
		var o = r.expr({ "a" : { "b" : 1, "c" : 2 }, "d" : 3 });
		assertAtom({ "a" : { "b" : 1, "c" : 2 }, "d" : 3, "e" : 4, "f" : 5 }, o.merge({ "e" : 4 }, { "f" : 5 }));
		assertAtom([{ "a" : { "b" : 1, "c" : 2 }, "d" : 3, "e" : 3 }, { "a" : { "b" : 1, "c" : 2 }, "d" : 4, "e" : 4 }], r.expr([o, o.merge({ "d" : 4 })]).merge(function(row) return { "e" : row["d"] }));
		assertAtom([{ "a" : { "b" : 1, "c" : 2 }, "d" : 3, "e" : 3 }, { "a" : { "b" : 1, "c" : 2 }, "d" : 4, "e" : 4 }], r.expr([o, o.merge({ "d" : 4 })]).merge({ "e" : r.row["d"] }));
		assertAtom([{ "a" : { "b" : 2, "c" : 2 }, "d" : 3 }, { "a" : { "b" : 2, "c" : 2 }, "d" : 4 }], r.expr([o, o.merge({ "d" : 4 })]).merge(function(row) return { "a" : { "b" : 2 } }));
		assertAtom([{ "a" : { "b" : 2 }, "d" : 3 }, { "a" : { "b" : 2 }, "d" : 4 }], r.expr([o, o.merge({ "d" : 4 })]).merge(function(row) return { "a" : r.literal({ "b" : 2 }) }));
		assertAtom(["a", "b", "c", "d", "e"], obj.keys());
		assertAtom([1, 2, "str", null, { "f" : "buzz" }], obj.values());
		assertAtom(5, obj.count());
	}
}